import re
from enum import Enum


class AddressParts(Enum):
    """An enum containing all possible values for address parts"""
    name = 'N'
    organisation = 'O'
    street_address = 'A'
    dependent_locality = 'D'
    city = 'C'
    admin_area = 'S'
    postal_code = 'Z'
    sorting_code = 'X'

    # Country is special, since we made up this character ourselves.
    country = '0'

    @classmethod
    def significant(cls):
        """
        An ordered, reversed list of parts, so that the first item is the
        largest topological division. This also strips out postal and sorting
        code, since they're independent from all the others.
        """
        ordered_values = cls.__members__.values()
        reverse = reversed(list(ordered_values))
        return list(filter(lambda p: not p.name.endswith('_code'), reverse))


class InvalidAddressException(ValueError):
    pass


class FieldValue(object):
    def __init__(self, value, details, subs):
        self.value = value
        self.details = details
        self.subs = subs


class Address(object):
    """An address value.

    The Address class can save and validate a full address, from any of the
    countries specified in the specifications passed to it. These
    specifications should be generated by the generate.download module, as they
    adhere to Google's i18n imported values.

    Mostly, you'll want to use the `get_data()`, `get_field_types()` and
    `set_field()` methods. These three methods should allow you to create a
    form that dynamically responds to any data and shows only relevant form
    fields. You can then simply call `str(address)` to get a fully valid
    address string, which you could use to send emails, for example.
    """

    def __init__(self, specs, values=None):
        self.specs = specs
        self.defaults = FieldValue('', specs['details'], specs['subs'])

        self.fields = {}
        if values is not None:
            for field, value in values.items():
                self.set_field(field, value)

    def field_in_fmt(self, part):
        if part == AddressParts.country:
            return True

        data = self.get_specs()
        return '%{0}'.format(part.value) in data['fmt']

    def get_significant_fields(self):
        """
        Get a list of (key, value) objects of fields sorted by
        significance.
        """
        return sorted(
            filter(lambda f: not f[0].name.endswith('_code'),
                   self.fields.items()),
            key=lambda i: AddressParts.significant().index(i[0])
        )

    def get_specs(self):
        """Get an up-to-date list of specifications for the address.

        This returns a specs dict, based on the details of the filled in fields
        but falling back to the defaults from the specs. It takes the specs
        from the least significant field.
        """
        specs = self.defaults.details

        for field, value in self.get_significant_fields():
            specs.update(value.details)

        return specs

    def get_field_types(self):
        """Gets a list of currently known-about fields."""
        fields = []
        # add the country now, since it's always the first field to fill in
        fields.append((AddressParts.country, tuple(self.defaults.subs)))
        data = self.get_specs()

        if 'fmt' not in data:
            return fields

        # we want only parts we have, by significance
        sig = [part for part in AddressParts.significant()
               if self.field_in_fmt(part)]

        for depth, part in enumerate(sig):
            # already have this
            if part == AddressParts.country:
                continue

            # we want to know if the "parent field" has choices for this field
            # because if it does, but no option is chosen yet, we can'ts how
            # the other fields
            options = None
            parent = depth - 1
            parent_part = sig[parent]

            if fields[parent][1] is not None and \
               parent_part not in self.fields:
                break

            # otherwise, if it is filled in, we only need to see if it has
            # options
            elif parent_part in self.fields:
                relevant = self.fields[parent_part]
                if len(relevant.subs) > 0:
                    options = tuple(relevant.subs)

            fields.append((part, options))
        else:
            fields.append((AddressParts.postal_code, None))
            fields.append((AddressParts.sorting_code, None))

        return fields

    def get_detail(self, field, prop):
        """
        Gets the value of a detail property for a certain field, but falls back
        to the defaults.
        """
        details = self.fields[field].details
        return details.get(prop, self.defaults.details.get(prop, None))

    def set_field(self, field, value):
        chosen = {}

        if not field.name.endswith('_code'):
            sig = AddressParts.significant()
            depth = sig.index(field)

            if depth == 0:
                relevant_part = sig[0]
                relevant = self.defaults
            else:
                relevant_part = sig[depth - 1]
                if relevant_part not in self.fields:
                    relevant = False
                else:
                    relevant = self.fields[relevant_part]

            if relevant and (depth == 0 or 'sub_keys' in relevant.details):
                if value not in relevant.subs:
                    raise InvalidAddressException(
                        '{0} does not exist'.format(relevant_part.name))

                chosen = relevant.subs[value]

        self.fields[field] = FieldValue(
            value=value,
            details=chosen.get('details', {}),
            subs=chosen.get('subs', {})
        )

        if AddressParts.postal_code in self.fields:
            self.validate_postal_code()

    def validate_postal_code(self):
        postal_code = self.fields[AddressParts.postal_code].value

        regex = self.get_detail(AddressParts.country, 'zip')
        if not re.fullmatch(regex, postal_code):
            raise InvalidAddressException('Invalid postal code')

        for value in self.fields.values():
            if 'zip' not in value.details:
                continue

            regex = value.details['zip']
            if not re.match(regex, postal_code):
                raise InvalidAddressException('Invalid postal code')

    def is_valid(self):
        data = self.get_specs()

        for part in AddressParts.__members__.values():
            if part not in self.fields and part.value in data['require']:
                return False
        return True

    def __str__(self):
        data = self.get_specs()
        out = data['fmt']

        out = out.replace('%n', "\n")

        # replace each part by its value
        for part in AddressParts.__members__.values():
            # unless it doesn't exist
            if part not in self.fields:
                if part.value in data['require']:
                    raise KeyError('No value set for required field {0}'
                                   .format(part.name))

                out = out.replace('%{0}'.format(part.value), '')
                continue

            # possibly needs to be uppercase too
            val = self.fields[part].value
            if part.value in data['upper']:
                val = val.upper()

            out = out.replace('%{0}'.format(part.value), val)

        # append the country to the end
        out += "\n" + self.fields[AddressParts.country].details['name']

        # remove blank lines
        out = "\n".join(l.rstrip() for l in out.splitlines() if l.strip())

        return out
